<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÏÑºÏÑú Î≥º Í≤åÏûÑ - Sensor Game Hub</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 1200px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .game-header h1 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .game-header p {
            color: #666;
            font-size: 1.1em;
        }

        .main-content {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .session-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            padding: 25px;
            color: white;
            min-width: 280px;
            max-width: 350px;
            flex: 1;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }

        .session-panel h2 {
            font-size: 1.5em;
            margin-bottom: 20px;
            text-align: center;
        }

        .session-info {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .session-info label {
            display: block;
            font-size: 0.9em;
            margin-bottom: 5px;
            opacity: 0.9;
        }

        #session-code {
            font-size: 2em;
            font-weight: bold;
            letter-spacing: 3px;
            display: block;
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            margin-top: 5px;
        }

        #qr-code {
            background: white;
            border-radius: 10px;
            padding: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 230px;
            margin-bottom: 20px;
        }

        #qr-code img, #qr-code canvas {
            max-width: 200px;
            max-height: 200px;
            border-radius: 5px;
        }

        .sensor-status-container {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        #sensor-status {
            font-size: 1.1em;
            font-weight: bold;
            padding: 10px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        #sensor-status.disconnected {
            background: rgba(255, 107, 107, 0.3);
            color: #fff;
        }

        #sensor-status.connected {
            background: rgba(46, 213, 115, 0.3);
            color: #fff;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .game-area {
            flex: 2;
            min-width: 320px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .game-stats {
            display: flex;
            justify-content: space-around;
            gap: 15px;
            flex-wrap: wrap;
        }

        .stat-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            text-align: center;
            flex: 1;
            min-width: 100px;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .stat-box label {
            display: block;
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .stat-box .value {
            font-size: 1.8em;
            font-weight: bold;
        }

        .canvas-container {
            position: relative;
            background: #1a1a2e;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: auto;
            max-height: 600px;
        }

        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .game-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .game-overlay h2 {
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .game-overlay p {
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        .game-overlay button {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 1.2em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .game-overlay button:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(102, 126, 234, 0.6);
        }

        .game-overlay button:active {
            transform: translateY(0);
        }

        .controls-info {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            text-align: center;
        }

        .controls-info h3 {
            margin-bottom: 10px;
            color: #667eea;
        }

        .controls-info p {
            color: #666;
            line-height: 1.6;
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            animation: particleFloat 1s ease-out forwards;
        }

        @keyframes particleFloat {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }

        @media (max-width: 768px) {
            .game-container {
                padding: 15px;
            }

            .game-header h1 {
                font-size: 1.8em;
            }

            .main-content {
                flex-direction: column;
            }

            .session-panel {
                max-width: 100%;
            }

            .stat-box {
                min-width: 80px;
                padding: 10px 15px;
            }

            .stat-box .value {
                font-size: 1.4em;
            }
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .instruction-banner {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
            animation: slideDown 0.5s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .instruction-banner strong {
            font-size: 1.2em;
            display: block;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1>üéÆ ÏÑºÏÑú Î≥º Í≤åÏûÑ</h1>
            <p>Ïä§ÎßàÌä∏Ìè∞ÏùÑ Í∏∞Ïö∏Ïó¨ÏÑú Ìå®Îì§ÏùÑ ÏõÄÏßÅÏù¥Í≥† Î≤ΩÎèåÏùÑ Î™®Îëê Íπ®ÏÑ∏Ïöî!</p>
        </div>

        <div class="main-content">
            <!-- ÏÑ∏ÏÖò Ìå®ÎÑê -->
            <div class="session-panel">
                <h2>üì± ÏÑºÏÑú Ïó∞Í≤∞</h2>
                
                <div class="session-info">
                    <label>ÏÑ∏ÏÖò ÏΩîÎìú</label>
                    <span id="session-code">---</span>
                </div>

                <div id="qr-code">
                    <div class="loading"></div>
                </div>

                <div class="sensor-status-container">
                    <label>ÏÑºÏÑú ÏÉÅÌÉú</label>
                    <div id="sensor-status" class="disconnected">
                        ÏÑºÏÑú Ïó∞Í≤∞ ÎåÄÍ∏∞ Ï§ë...
                    </div>
                </div>

                <div class="controls-info">
                    <h3>üéØ Ï°∞Ïûë Î∞©Î≤ï</h3>
                    <p>
                        üì± <strong>Ï¢åÏö∞ Í∏∞Ïö∏Ïù¥Í∏∞</strong>: Ìå®Îì§ Ïù¥Îèô<br>
                        üì≥ <strong>ÌùîÎì§Í∏∞</strong>: Í≤åÏûÑ ÏãúÏûë<br>
                        üéØ <strong>Î™©Ìëú</strong>: Î™®Îì† Î≤ΩÎèå ÌååÍ¥¥!
                    </p>
                </div>
            </div>

            <!-- Í≤åÏûÑ ÏòÅÏó≠ -->
            <div class="game-area">
                <div class="game-stats">
                    <div class="stat-box">
                        <label>Ï†êÏàò</label>
                        <div class="value" id="score-display">0</div>
                    </div>
                    <div class="stat-box">
                        <label>ÏÉùÎ™Ö</label>
                        <div class="value" id="lives-display">3</div>
                    </div>
                    <div class="stat-box">
                        <label>Î†àÎ≤®</label>
                        <div class="value" id="level-display">1</div>
                    </div>
                    <div class="stat-box">
                        <label>Î≤ΩÎèå</label>
                        <div class="value" id="bricks-display">0</div>
                    </div>
                </div>

                <div class="canvas-container">
                    <canvas id="gameCanvas" width="800" height="600"></canvas>
                    
                    <div class="game-overlay active" id="game-overlay">
                        <h2 id="overlay-title">ÏÑºÏÑúÎ•º Ïó∞Í≤∞ÌïòÏÑ∏Ïöî!</h2>
                        <p id="overlay-message">QR ÏΩîÎìúÎ•º Ïä§Ï∫îÌïòÏó¨ Ïä§ÎßàÌä∏Ìè∞ÏùÑ Ïó∞Í≤∞ÌïòÏÑ∏Ïöî</p>
                        <p id="overlay-submessage">Ïó∞Í≤∞ ÌõÑ ÌùîÎì§Ïñ¥ÏÑú Í≤åÏûÑÏùÑ ÏãúÏûëÌïòÏÑ∏Ïöî</p>
                    </div>
                </div>

                <div class="instruction-banner" id="instruction-banner" style="display: none;">
                    <strong>üéÆ Í≤åÏûÑ ÏãúÏûë!</strong>
                    Ïä§ÎßàÌä∏Ìè∞ÏùÑ ÌùîÎì§Í±∞ÎÇò ÌôîÎ©¥ÏùÑ ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî
                </div>
            </div>
        </div>
    </div>

    <!-- ÌïÑÏàò Ïä§ÌÅ¨Î¶ΩÌä∏ -->
    <script src="/socket.io/socket.io.js"></script>
    <script src="/js/SessionSDK.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

    <script>
        // ==================== Í≤åÏûÑ ÏÉÅÏàò Ï†ïÏùò ====================
        const GAME_CONFIG = {
            // Ï∫îÎ≤ÑÏä§ ÏÑ§Ï†ï
            CANVAS_WIDTH: 800,
            CANVAS_HEIGHT: 600,
            
            // Ìå®Îì§ ÏÑ§Ï†ï
            PADDLE_WIDTH: 120,
            PADDLE_HEIGHT: 20,
            PADDLE_SPEED: 8,
            PADDLE_Y_OFFSET: 50,
            
            // Í≥µ ÏÑ§Ï†ï
            BALL_RADIUS: 10,
            BALL_INITIAL_SPEED: 5,
            BALL_MAX_SPEED: 12,
            BALL_SPEED_INCREMENT: 0.3,
            
            // Î≤ΩÎèå ÏÑ§Ï†ï
            BRICK_ROWS: 5,
            BRICK_COLS: 8,
            BRICK_WIDTH: 90,
            BRICK_HEIGHT: 30,
            BRICK_PADDING: 10,
            BRICK_OFFSET_TOP: 60,
            BRICK_OFFSET_LEFT: 35,
            
            // Í≤åÏûÑ ÏÑ§Ï†ï
            INITIAL_LIVES: 3,
            POINTS_PER_BRICK: 10,
            SHAKE_THRESHOLD: 20,
            TILT_SENSITIVITY: 15,
            
            // ÏÉâÏÉÅ ÌåîÎ†àÌä∏
            COLORS: {
                paddle: '#667eea',
                ball: '#f5576c',
                bricks: [
                    '#ff6b6b', '#ee5a6f', '#f06595', '#cc5de8', '#845ef7',
                    '#5c7cfa', '#339af0', '#22b8cf', '#20c997', '#51cf66',
                    '#94d82d', '#fcc419', '#ff922b', '#ff6b6b', '#f06595'
                ],
                background: '#1a1a2e',
                text: '#ffffff'
            }
        };

        // ==================== Í≤åÏûÑ ÏÉÅÌÉú Î≥ÄÏàò ====================
        let canvas, ctx;
        let gameStarted = false;
        let gamePaused = false;
        let gameOver = false;
        let sensorConnected = false;
        let animationFrameId = null;

        // Í≤åÏûÑ Ïò§Î∏åÏ†ùÌä∏
        let paddle = {
            x: 0,
            y: 0,
            width: GAME_CONFIG.PADDLE_WIDTH,
            height: GAME_CONFIG.PADDLE_HEIGHT,
            speed: GAME_CONFIG.PADDLE_SPEED,
            targetX: 0
        };

        let ball = {
            x: 0,
            y: 0,
            radius: GAME_CONFIG.BALL_RADIUS,
            dx: 0,
            dy: 0,
            speed: GAME_CONFIG.BALL_INITIAL_SPEED,
            stuck: true
        };

        // Í≤åÏûÑ ÌÜµÍ≥Ñ
        let score = 0;
        let lives = GAME_CONFIG.INITIAL_LIVES;
        let level = 1;
        let bricks = [];
        let bricksRemaining = 0;

        // ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞
        let currentTilt = 0;
        let lastShakeTime = 0;

        // ÌååÌã∞ÌÅ¥ Ìö®Í≥º
        let particles = [];

        // ==================== SessionSDK Ï¥àÍ∏∞Ìôî ====================
        const sdk = new SessionSDK({
            gameId: 'ÏÑºÏÑú Î≥º Í≤åÏûÑ',
            gameType: 'solo'
        });

        // ==================== SDK Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨ ====================
        sdk.on('connected', () => {
            console.log('‚úÖ ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏôÑÎ£å');
            createSession();
        });

        sdk.on('session-created', (event) => {
            const session = event.detail || event;
            console.info('‚úÖ ÏÑ∏ÏÖò ÏÉùÏÑ± ÏôÑÎ£å:', session);

            // ÏÑ∏ÏÖò ÏΩîÎìú ÌëúÏãú
            const sessionCodeEl = document.getElementById('session-code');
            if (sessionCodeEl && session.sessionCode) {
                sessionCodeEl.textContent = session.sessionCode;
                console.info('ÏÑ∏ÏÖò ÏΩîÎìú ÌëúÏãú:', session.sessionCode);
            }

            // QR ÏΩîÎìú ÏÉùÏÑ±
            setTimeout(() => {
                const qrUrl = `${window.location.origin}/sensor.html?session=${session.sessionCode}`;
                console.info('QR URL ÏÉùÏÑ±:', qrUrl);
                generateQRCode(qrUrl);
            }, 100);
        });

        sdk.on('sensor-connected', (event) => {
            const data = event.detail || event;
            console.log('‚úÖ ÏÑºÏÑú Ïó∞Í≤∞Îê®:', data.sensorId);

            sensorConnected = true;

            // UI ÏóÖÎç∞Ïù¥Ìä∏
            const statusEl = document.getElementById('sensor-status');
            statusEl.textContent = 'ÏÑºÏÑú Ïó∞Í≤∞Îê® ‚úì';
            statusEl.className = 'connected';

            // Ïò§Î≤ÑÎ†àÏù¥ ÏóÖÎç∞Ïù¥Ìä∏
            const overlay = document.getElementById('game-overlay');
            const overlayTitle = document.getElementById('overlay-title');
            const overlayMessage = document.getElementById('overlay-message');
            const overlaySubmessage = document.getElementById('overlay-submessage');

            overlayTitle.textContent = 'Ï§ÄÎπÑ ÏôÑÎ£å!';
            overlayMessage.textContent = 'Ïä§ÎßàÌä∏Ìè∞ÏùÑ ÌùîÎì§Ïñ¥ÏÑú Í≤åÏûÑÏùÑ ÏãúÏûëÌïòÏÑ∏Ïöî';
            overlaySubmessage.textContent = 'ÎòêÎäî ÌôîÎ©¥ÏùÑ ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî';

            // ÏïàÎÇ¥ Î∞∞ÎÑà ÌëúÏãú
            const banner = document.getElementById('instruction-banner');
            banner.style.display = 'block';

            // ÏûêÎèô ÏãúÏûë ÌÉÄÏù¥Î®∏ (3Ï¥à ÌõÑ)
            setTimeout(() => {
                if (!gameStarted && !gameOver && sensorConnected) {
                    console.log('üéÆ ÏûêÎèô Í≤åÏûÑ ÏãúÏûë');
                    startGame();
                }
            }, 3000);
        });

        sdk.on('sensor-disconnected', (event) => {
            const data = event.detail || event;
            console.log('‚ö†Ô∏è ÏÑºÏÑú Ïó∞Í≤∞ Ìï¥Ï†ú:', data.sensorId);

            sensorConnected = false;

            // UI ÏóÖÎç∞Ïù¥Ìä∏
            const statusEl = document.getElementById('sensor-status');
            statusEl.textContent = 'ÏÑºÏÑú Ïó∞Í≤∞ ÎåÄÍ∏∞ Ï§ë...';
            statusEl.className = 'disconnected';

            // Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ
            if (gameStarted && !gameOver) {
                gamePaused = true;
                const overlay = document.getElementById('game-overlay');
                const overlayTitle = document.getElementById('overlay-title');
                const overlayMessage = document.getElementById('overlay-message');
                
                overlayTitle.textContent = 'ÏùºÏãúÏ†ïÏßÄ';
                overlayMessage.textContent = 'ÏÑºÏÑú Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥Ï°åÏäµÎãàÎã§';
                overlay.classList.add('active');
            }
        });

        sdk.on('sensor-data', (event) => {
            const data = event.detail || event;
            processSensorData(data);
        });

        // ==================== ÏÑ∏ÏÖò ÏÉùÏÑ± Ìï®Ïàò ====================
        function createSession() {
            sdk.createSession().then(session => {
                console.log('‚úÖ ÏÑ∏ÏÖò ÏÉùÏÑ±Îê®:', session);
            }).catch(error => {
                console.error('‚ùå ÏÑ∏ÏÖò ÏÉùÏÑ± Ïã§Ìå®:', error);
                alert('ÏÑ∏ÏÖò ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ' + error.message);
            });
        }

        // ==================== QR ÏΩîÎìú ÏÉùÏÑ± Ìï®Ïàò ====================
        function generateQRCode(url) {
            const qrContainer = document.getElementById('qr-code');
            qrContainer.innerHTML = '';

            if (typeof QRCode !== 'undefined') {
                try {
                    new QRCode(qrContainer, {
                        text: url,
                        width: 200,
                        height: 200,
                        colorDark: '#000000',
                        colorLight: '#ffffff',
                        correctLevel: QRCode.CorrectLevel.H
                    });
                    console.log('‚úÖ QR ÏΩîÎìú ÏÉùÏÑ± ÏôÑÎ£å (QRCode.js)');
                } catch (error) {
                    console.error('QRCode.js Ïò§Î•ò:', error);
                    generateQRCodeFallback(url, qrContainer);
                }
            } else {
                console.log('‚ö†Ô∏è QRCode.js ÏóÜÏùå, Ìè¥Î∞± ÏÇ¨Ïö©');
                generateQRCodeFallback(url, qrContainer);
            }
        }

        function generateQRCodeFallback(url, container) {
            const img = document.createElement('img');
            img.src = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(url)}`;
            img.alt = 'QR Code';
            img.style.width = '200px';
            img.style.height = '200px';
            container.appendChild(img);
            console.log('‚úÖ QR ÏΩîÎìú ÏÉùÏÑ± ÏôÑÎ£å (Ìè¥Î∞± API)');
        }

        // ==================== ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ ====================
        function processSensorData(sensorData) {
            if (!sensorData || !sensorData.data) return;

            const { orientation, acceleration } = sensorData.data;

            // Ï¢åÏö∞ Í∏∞Ïö∏Í∏∞Î°ú Ìå®Îì§ Ïù¥Îèô (gamma: -90 ~ 90)
            if (orientation && orientation.gamma !== null) {
                // gamma Í∞íÏùÑ -1 ~ 1Î°ú Ï†ïÍ∑úÌôî
                let tiltValue = orientation.gamma / 90;
                
                // ÎØºÍ∞êÎèÑ Ï°∞Ï†ï Î∞è Î≤îÏúÑ Ï†úÌïú
                tiltValue = Math.max(-1, Math.min(1, tiltValue));
                
                // Ìå®Îì§ Î™©Ìëú ÏúÑÏπò Í≥ÑÏÇ∞
                currentTilt = tiltValue;
                const centerX = canvas.width / 2;
                const maxOffset = (canvas.width / 2) - (paddle.width / 2);
                paddle.targetX = centerX + (tiltValue * maxOffset * (GAME_CONFIG.TILT_SENSITIVITY / 10));
                
                // Î≤îÏúÑ Ï†úÌïú
                paddle.targetX = Math.max(paddle.width / 2, Math.min(canvas.width - paddle.width / 2, paddle.targetX));
            }

            // ÌùîÎì§Í∏∞ Í∞êÏßÄÎ°ú Í≤åÏûÑ ÏãúÏûë
            if (acceleration) {
                const shake = Math.sqrt(
                    Math.pow(acceleration.x || 0, 2) +
                    Math.pow(acceleration.y || 0, 2) +
                    Math.pow(acceleration.z || 0, 2)
                );

                const currentTime = Date.now();
                
                // ÌùîÎì§Í∏∞Î°ú Í≤åÏûÑ ÏãúÏûë
                if (!gameStarted && shake > GAME_CONFIG.SHAKE_THRESHOLD && 
                    sensorConnected && !gameOver && 
                    currentTime - lastShakeTime > 1000) {
                    
                    lastShakeTime = currentTime;
                    console.log('üî• ÌùîÎì§Í∏∞ Í∞êÏßÄ! Í≤åÏûÑ ÏãúÏûë');
                    startGame();
                }

                // Í≤åÏûÑ Ïò§Î≤Ñ ÌõÑ ÌùîÎì§Í∏∞Î°ú Ïû¨ÏãúÏûë
                if (gameOver && shake > GAME_CONFIG.SHAKE_THRESHOLD && 
                    currentTime - lastShakeTime > 1000) {
                    
                    lastShakeTime = currentTime;
                    console.log('üî• ÌùîÎì§Í∏∞ Í∞êÏßÄ! Í≤åÏûÑ Ïû¨ÏãúÏûë');
                    resetGame();
                }
            }
        }

        // ==================== Í≤åÏûÑ Ï¥àÍ∏∞Ìôî ====================
        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            // Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ ÏÑ§Ï†ï
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Ìå®Îì§ Ï¥àÍ∏∞ ÏúÑÏπò
            paddle.x = canvas.width / 2;
            paddle.y = canvas.height - GAME_CONFIG.PADDLE_Y_OFFSET;
            paddle.targetX = paddle.x;

            // Í≥µ Ï¥àÍ∏∞ ÏúÑÏπò (Ìå®Îì§ ÏúÑÏóê Î∂ôÏñ¥ÏûàÏùå)
            resetBall();

            // Î≤ΩÎèå ÏÉùÏÑ±
            createBricks();

            // UI ÏóÖÎç∞Ïù¥Ìä∏
            updateUI();

            // ÌÅ¥Î¶≠ÏúºÎ°ú Í≤åÏûÑ ÏãúÏûë
            canvas.addEventListener('click', () => {
                if (!gameStarted && !gameOver && sensorConnected) {
                    startGame();
                } else if (gameOver) {
                    resetGame();
                }
            });

            // Í≤åÏûÑ Î£®ÌîÑ ÏãúÏûë
            gameLoop();

            console.log('‚úÖ Í≤åÏûÑ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
        }

        // ==================== Ï∫îÎ≤ÑÏä§ Î¶¨ÏÇ¨Ïù¥Ï¶à ====================
        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth;
            const aspectRatio = GAME_CONFIG.CANVAS_HEIGHT / GAME_CONFIG.CANVAS_WIDTH;
            
            canvas.style.width = '100%';
            canvas.style.height = (containerWidth * aspectRatio) + 'px';
        }

        // ==================== Î≤ΩÎèå ÏÉùÏÑ± ====================
        function createBricks() {
            bricks = [];
            bricksRemaining = 0;

            for (let row = 0; row < GAME_CONFIG.BRICK_ROWS; row++) {
                bricks[row] = [];
                for (let col = 0; col < GAME_CONFIG.BRICK_COLS; col++) {
                    const brick = {
                        x: col * (GAME_CONFIG.BRICK_WIDTH + GAME_CONFIG.BRICK_PADDING) + GAME_CONFIG.BRICK_OFFSET_LEFT,
                        y: row * (GAME_CONFIG.BRICK_HEIGHT + GAME_CONFIG.BRICK_PADDING) + GAME_CONFIG.BRICK_OFFSET_TOP,
                        width: GAME_CONFIG.BRICK_WIDTH,
                        height: GAME_CONFIG.BRICK_HEIGHT,
                        status: 1,
                        color: GAME_CONFIG.COLORS.bricks[row % GAME_CONFIG.COLORS.bricks.length],
                        points: GAME_CONFIG.POINTS_PER_BRICK * (GAME_CONFIG.BRICK_ROWS - row)
                    };
                    bricks[row][col] = brick;
                    bricksRemaining++;
                }
            }

            updateUI();
        }

        // ==================== Í≤åÏûÑ ÏãúÏûë ====================
        function startGame() {
            if (gameStarted || !sensorConnected) return;

            gameStarted = true;
            gamePaused = false;
            ball.stuck = false;

            // Í≥µÏóê Ï¥àÍ∏∞ ÏÜçÎèÑ Î∂ÄÏó¨ (ÏúÑÏ™Ω ÎåÄÍ∞ÅÏÑ†)
            const angle = -60 + (Math.random() * 60 - 30); // -75ÎèÑ ~ -45ÎèÑ
            const radians = angle * Math.PI / 180;
            ball.dx = ball.speed * Math.sin(radians);
            ball.dy = -ball.speed * Math.cos(radians);

            // Ïò§Î≤ÑÎ†àÏù¥ Ïà®Í∏∞Í∏∞
            const overlay = document.getElementById('game-overlay');
            overlay.classList.remove('active');

            // ÏïàÎÇ¥ Î∞∞ÎÑà Ïà®Í∏∞Í∏∞
            const banner = document.getElementById('instruction-banner');
            banner.style.display = 'none';

            console.log('üéÆ Í≤åÏûÑ ÏãúÏûë!', { dx: ball.dx, dy: ball.dy });
        }

        // ==================== Í≥µ Î¶¨ÏÖã ====================
        function resetBall() {
            ball.stuck = true;
            ball.x = paddle.x;
            ball.y = paddle.y - ball.radius - 5;
            ball.dx = 0;
            ball.dy = 0;
            ball.speed = GAME_CONFIG.BALL_INITIAL_SPEED;
        }

        // ==================== Í≤åÏûÑ Î£®ÌîÑ ====================
        function gameLoop() {
            updateGame();
            renderGame();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // ==================== Í≤åÏûÑ ÏóÖÎç∞Ïù¥Ìä∏ ====================
        function updateGame() {
            if (!gameStarted || gamePaused || gameOver) {
                // Í≤åÏûÑÏù¥ ÏãúÏûëÎêòÏßÄ ÏïäÏïòÍ±∞ÎÇò ÏùºÏãúÏ†ïÏßÄ ÏÉÅÌÉú
                if (ball.stuck) {
                    // Í≥µÏù¥ Ìå®Îì§Ïóê Î∂ôÏñ¥ÏûàÏùÑ Îïå Ìå®Îì§ Îî∞Îùº Ïù¥Îèô
                    ball.x = paddle.x;
                    ball.y = paddle.y - ball.radius - 5;
                }
                
                // Ìå®Îì§ÏùÄ ÏÑºÏÑú ÏûÖÎ†•Ïóê Îî∞Îùº Î∂ÄÎìúÎüΩÍ≤å Ïù¥Îèô
                updatePaddle();
                return;
            }

            // Ìå®Îì§ ÏóÖÎç∞Ïù¥Ìä∏
            updatePaddle();

            // Í≥µÏù¥ Î∂ôÏñ¥ÏûàÏßÄ ÏïäÏùÑ ÎïåÎßå Ïù¥Îèô
            if (!ball.stuck) {
                // Í≥µ Ïù¥Îèô
                ball.x += ball.dx;
                ball.y += ball.dy;

                // Î≤Ω Ï∂©Îèå (Ï¢åÏö∞)
                if (ball.x - ball.radius <= 0 || ball.x + ball.radius >= canvas.width) {
                    ball.dx = -ball.dx;
                    ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x));
                    createParticles(ball.x, ball.y, '#ffffff', 5);
                }

                // Î≤Ω Ï∂©Îèå (ÏúÑ)
                if (ball.y - ball.radius <= 0) {
                    ball.dy = -ball.dy;
                    ball.y = ball.radius;
                    createParticles(ball.x, ball.y, '#ffffff', 5);
                }

                // Ìå®Îì§ Ï∂©Îèå
                if (checkPaddleCollision()) {
                    // Í≥µÏù¥ Ìå®Îì§ Ïñ¥ÎîîÏóê ÎßûÏïòÎäîÏßÄÏóê Îî∞Îùº Î∞òÏÇ¨Í∞Å Ï°∞Ï†ï
                    const hitPos = (ball.x - paddle.x) / paddle.width; // 0 ~ 1
                    const angle = (hitPos - 0.5) * 120; // -60ÎèÑ ~ 60ÎèÑ
                    const radians = angle * Math.PI / 180;
                    
                    const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                    ball.dx = speed * Math.sin(radians);
                    ball.dy = -Math.abs(speed * Math.cos(radians)); // Ìï≠ÏÉÅ ÏúÑÎ°ú
                    
                    // ÏÜçÎèÑ Ï¶ùÍ∞Ä (ÏµúÎåÄ ÏÜçÎèÑ Ï†úÌïú)
                    if (ball.speed < GAME_CONFIG.BALL_MAX_SPEED) {
                        ball.speed += GAME_CONFIG.BALL_SPEED_INCREMENT;
                        const currentSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                        ball.dx = (ball.dx / currentSpeed) * ball.speed;
                        ball.dy = (ball.dy / currentSpeed) * ball.speed;
                    }

                    createParticles(ball.x, ball.y, GAME_CONFIG.COLORS.paddle, 8);
                }

                // Î≤ΩÎèå Ï∂©Îèå
                checkBrickCollision();

                // Í≥µÏù¥ ÏïÑÎûòÎ°ú Îñ®Ïñ¥Ïßê
                if (ball.y - ball.radius > canvas.height) {
                    lives--;
                    updateUI();
                    createParticles(ball.x, canvas.height, GAME_CONFIG.COLORS.ball, 15);

                    if (lives <= 0) {
                        // Í≤åÏûÑ Ïò§Î≤Ñ
                        endGame(false);
                    } else {
                        // Í≥µ Î¶¨ÏÖã
                        resetBall();
                        gameStarted = false;
                        
                        // Ïû†Ïãú ÌõÑ ÏûêÎèô Ïû¨ÏãúÏûë
                        setTimeout(() => {
                            if (!gameOver && sensorConnected) {
                                startGame();
                            }
                        }, 1000);
                    }
                }

                // Î™®Îì† Î≤ΩÎèå ÌååÍ¥¥ Ïãú Î†àÎ≤® ÌÅ¥Î¶¨Ïñ¥
                if (bricksRemaining <= 0) {
                    levelComplete();
                }
            }

            // ÌååÌã∞ÌÅ¥ ÏóÖÎç∞Ïù¥Ìä∏
            updateParticles();
        }

        // ==================== Ìå®Îì§ ÏóÖÎç∞Ïù¥Ìä∏ ====================
        function updatePaddle() {
            // Î∂ÄÎìúÎü¨Ïö¥ Ïù¥Îèô (ÏÑ†Ìòï Î≥¥Í∞Ñ)
            const dx = paddle.targetX - paddle.x;
            paddle.x += dx * 0.2; // 20% Ïî© Ïù¥Îèô (Î∂ÄÎìúÎü¨Ïö¥ Ìö®Í≥º)

            // Î≤îÏúÑ Ï†úÌïú
            paddle.x = Math.max(paddle.width / 2, Math.min(canvas.width - paddle.width / 2, paddle.x));
        }

        // ==================== Ìå®Îì§ Ï∂©Îèå Í∞êÏßÄ ====================
        function checkPaddleCollision() {
            // Í≥µÏù¥ Ìå®Îì§ ÏòÅÏó≠Ïóê ÏûàÎäîÏßÄ ÌôïÏù∏
            if (ball.y + ball.radius >= paddle.y &&
                ball.y + ball.radius <= paddle.y + paddle.height &&
                ball.x >= paddle.x - paddle.width / 2 &&
                ball.x <= paddle.x + paddle.width / 2 &&
                ball.dy > 0) { // ÏïÑÎûòÎ°ú Ïù¥Îèô Ï§ëÏùº ÎïåÎßå
                
                ball.y = paddle.y - ball.radius; // Í≥µÏùÑ Ìå®Îì§ ÏúÑÎ°ú
                return true;
            }
            return false;
        }

        // ==================== Î≤ΩÎèå Ï∂©Îèå Í∞êÏßÄ ====================
        function checkBrickCollision() {
            for (let row = 0; row < GAME_CONFIG.BRICK_ROWS; row++) {
                for (let col = 0; col < GAME_CONFIG.BRICK_COLS; col++) {
                    const brick = bricks[row][col];
                    
                    if (brick.status === 1) {
                        // AABB Ï∂©Îèå Í∞êÏßÄ
                        if (ball.x + ball.radius > brick.x &&
                            ball.x - ball.radius < brick.x + brick.width &&
                            ball.y + ball.radius > brick.y &&
                            ball.y - ball.radius < brick.y + brick.height) {
                            
                            // Ï∂©Îèå Î∞©Ìñ• Í≥ÑÏÇ∞
                            const ballCenterX = ball.x;
                            const ballCenterY = ball.y;
                            const brickCenterX = brick.x + brick.width / 2;
                            const brickCenterY = brick.y + brick.height / 2;
                            
                            const dx = ballCenterX - brickCenterX;
                            const dy = ballCenterY - brickCenterY;
                            
                            const width = (brick.width + ball.radius * 2) / 2;
                            const height = (brick.height + ball.radius * 2) / 2;
                            
                            const crossWidth = width * dy;
                            const crossHeight = height * dx;
                            
                            // Ï∂©Îèå Î∞©Ìñ•Ïóê Îî∞Îùº Î∞òÏÇ¨
                            if (Math.abs(crossWidth) > Math.abs(crossHeight)) {
                                // ÏúÑ/ÏïÑÎûò Ï∂©Îèå
                                ball.dy = -ball.dy;
                            } else {
                                // Ï¢å/Ïö∞ Ï∂©Îèå
                                ball.dx = -ball.dx;
                            }
                            
                            // Î≤ΩÎèå ÌååÍ¥¥
                            brick.status = 0;
                            bricksRemaining--;
                            score += brick.points;
                            
                            // ÌååÌã∞ÌÅ¥ Ìö®Í≥º
                            createParticles(
                                brick.x + brick.width / 2,
                                brick.y + brick.height / 2,
                                brick.color,
                                12
                            );
                            
                            updateUI();
                            
                            // Ìïú ÌîÑÎ†àÏûÑÏóê ÌïòÎÇòÏùò Î≤ΩÎèåÎßå Ï≤òÎ¶¨
                            return;
                        }
                    }
                }
            }
        }

        // ==================== Î†àÎ≤® ÏôÑÎ£å ====================
        function levelComplete() {
            level++;
            gameStarted = false;
            
            // Î≥¥ÎÑàÏä§ Ï†êÏàò
            score += lives * 50;
            
            // Ïò§Î≤ÑÎ†àÏù¥ ÌëúÏãú
            const overlay = document.getElementById('game-overlay');
            const overlayTitle = document.getElementById('overlay-title');
            const overlayMessage = document.getElementById('overlay-message');
            const overlaySubmessage = document.getElementById('overlay-submessage');
            
            overlayTitle.textContent = `Î†àÎ≤® ${level - 1} ÌÅ¥Î¶¨Ïñ¥! üéâ`;
            overlayMessage.textContent = `Ï†êÏàò: ${score}`;
            overlaySubmessage.textContent = 'Îã§Ïùå Î†àÎ≤® Ï§ÄÎπÑ Ï§ë...';
            overlay.classList.add('active');
            
            // Îã§Ïùå Î†àÎ≤® Ï§ÄÎπÑ
            setTimeout(() => {
                createBricks();
                resetBall();
                ball.speed = GAME_CONFIG.BALL_INITIAL_SPEED + (level - 1) * 0.5;
                updateUI();
                
                overlay.classList.remove('active');
                
                // ÏûêÎèô ÏãúÏûë
                setTimeout(() => {
                    if (sensorConnected && !gameOver) {
                        startGame();
                    }
                }, 500);
            }, 2000);
        }

        // ==================== Í≤åÏûÑ Ï¢ÖÎ£å ====================
        function endGame(won) {
            gameStarted = false;
            gameOver = true;
            
            const overlay = document.getElementById('game-overlay');
            const overlayTitle = document.getElementById('overlay-title');
            const overlayMessage = document.getElementById('overlay-message');
            const overlaySubmessage = document.getElementById('overlay-submessage');
            
            if (won) {
                overlayTitle.textContent = 'üèÜ Í≤åÏûÑ ÌÅ¥Î¶¨Ïñ¥!';
                overlayMessage.textContent = `ÏµúÏ¢Ö Ï†êÏàò: ${score}`;
                overlaySubmessage.textContent = 'Ï∂ïÌïòÌï©ÎãàÎã§!';
            } else {
                overlayTitle.textContent = 'üí• Í≤åÏûÑ Ïò§Î≤Ñ';
                overlayMessage.textContent = `ÏµúÏ¢Ö Ï†êÏàò: ${score}`;
                overlaySubmessage.textContent = 'ÌùîÎì§Ïñ¥ÏÑú Îã§Ïãú ÏãúÏûëÌïòÏÑ∏Ïöî';
            }
            
            overlay.classList.add('active');
            
            console.log('üéÆ Í≤åÏûÑ Ï¢ÖÎ£å:', { won, score, level });
        }

        // ==================== Í≤åÏûÑ Î¶¨ÏÖã ====================
        function resetGame() {
            gameStarted = false;
            gameOver = false;
            gamePaused = false;
            
            score = 0;
            lives = GAME_CONFIG.INITIAL_LIVES;
            level = 1;
            
            paddle.x = canvas.width / 2;
            paddle.targetX = paddle.x;
            
            resetBall();
            createBricks();
            updateUI();
            
            const overlay = document.getElementById('game-overlay');
            overlay.classList.remove('active');
            
            // ÏûêÎèô ÏãúÏûë
            setTimeout(() => {
                if (sensorConnected && !gameOver) {
                    startGame();
                }
            }, 500);
            
            console.log('üîÑ Í≤åÏûÑ Î¶¨ÏÖã');
        }

        // ==================== ÌååÌã∞ÌÅ¥ ÏÉùÏÑ± ====================
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                const velocity = 2 + Math.random() * 3;
                
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * velocity,
                    vy: Math.sin(angle) * velocity,
                    color: color,
                    life: 1,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 3 + Math.random() * 3
                });
            }
        }

        // ==================== ÌååÌã∞ÌÅ¥ ÏóÖÎç∞Ïù¥Ìä∏ ====================
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                
                p.x += p.vx;
                p.y += p.vy;
                p.life -= p.decay;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        // ==================== UI ÏóÖÎç∞Ïù¥Ìä∏ ====================
        function updateUI() {
            document.getElementById('score-display').textContent = score;
            document.getElementById('lives-display').textContent = lives;
            document.getElementById('level-display').textContent = level;
            document.getElementById('bricks-display').textContent = bricksRemaining;
        }

        // ==================== Í≤åÏûÑ Î†åÎçîÎßÅ ====================
        function renderGame() {
            // Î∞∞Í≤Ω
            ctx.fillStyle = GAME_CONFIG.COLORS.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Í≤©Ïûê Ìå®ÌÑ¥ (Î∞∞Í≤Ω Ïû•Ïãù)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 40) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i < canvas.height; i += 40) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }

            // Î≤ΩÎèå Í∑∏Î¶¨Í∏∞
            drawBricks();

            // Ìå®Îì§ Í∑∏Î¶¨Í∏∞
            drawPaddle();

            // Í≥µ Í∑∏Î¶¨Í∏∞
            drawBall();

            // ÌååÌã∞ÌÅ¥ Í∑∏Î¶¨Í∏∞
            drawParticles();

            // ÏÑºÏÑú Ïó∞Í≤∞ ÏïàÎÇ¥ (Í≤åÏûÑ ÏãúÏûë Ï†Ñ)
            if (!gameStarted && !gameOver && sensorConnected) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ÌùîÎì§Ïñ¥ÏÑú ÏãúÏûëÌïòÏÑ∏Ïöî!', canvas.width / 2, canvas.height / 2);
                
                ctx.font = '18px Arial';
                ctx.fillText('ÎòêÎäî ÌôîÎ©¥ÏùÑ ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî', canvas.width / 2, canvas.height / 2 + 35);
            }

            // Í∏∞Ïö∏Í∏∞ Ïù∏ÎîîÏºÄÏù¥ÌÑ∞
            if (sensorConnected && gameStarted) {
                drawTiltIndicator();
            }
        }

        // ==================== Î≤ΩÎèå Í∑∏Î¶¨Í∏∞ ====================
        function drawBricks() {
            for (let row = 0; row < GAME_CONFIG.BRICK_ROWS; row++) {
                for (let col = 0; col < GAME_CONFIG.BRICK_COLS; col++) {
                    const brick = bricks[row][col];
                    
                    if (brick.status === 1) {
                        // Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ìö®Í≥º
                        const gradient = ctx.createLinearGradient(
                            brick.x, brick.y,
                            brick.x, brick.y + brick.height
                        );
                        gradient.addColorStop(0, brick.color);
                        gradient.addColorStop(1, shadeColor(brick.color, -20));
                        
                        ctx.fillStyle = gradient;
                        
                        // Îë•Í∑º Î™®ÏÑúÎ¶¨ ÏÇ¨Í∞ÅÌòï
                        roundRect(ctx, brick.x, brick.y, brick.width, brick.height, 5);
                        ctx.fill();
                        
                        // ÌÖåÎëêÎ¶¨
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 2;
                        roundRect(ctx, brick.x, brick.y, brick.width, brick.height, 5);
                        ctx.stroke();
                        
                        // ÌïòÏù¥ÎùºÏù¥Ìä∏
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                        roundRect(ctx, brick.x + 5, brick.y + 5, brick.width - 10, brick.height / 3, 3);
                        ctx.fill();
                    }
                }
            }
        }

        // ==================== Ìå®Îì§ Í∑∏Î¶¨Í∏∞ ====================
        function drawPaddle() {
            const x = paddle.x - paddle.width / 2;
            const y = paddle.y;
            
            // Í∑∏ÎùºÎç∞Ïù¥ÏÖò
            const gradient = ctx.createLinearGradient(x, y, x, y + paddle.height);
            gradient.addColorStop(0, GAME_CONFIG.COLORS.paddle);
            gradient.addColorStop(1, shadeColor(GAME_CONFIG.COLORS.paddle, -30));
            
            ctx.fillStyle = gradient;
            roundRect(ctx, x, y, paddle.width, paddle.height, 10);
            ctx.fill();
            
            // ÌÖåÎëêÎ¶¨
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 3;
            roundRect(ctx, x, y, paddle.width, paddle.height, 10);
            ctx.stroke();
            
            // ÌïòÏù¥ÎùºÏù¥Ìä∏
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            roundRect(ctx, x + 10, y + 5, paddle.width - 20, paddle.height / 3, 5);
            ctx.fill();
        }

        // ==================== Í≥µ Í∑∏Î¶¨Í∏∞ ====================
        function drawBall() {
            // Í∑∏ÎùºÎç∞Ïù¥ÏÖò
            const gradient = ctx.createRadialGradient(
                ball.x - ball.radius / 3, ball.y - ball.radius / 3, 0,
                ball.x, ball.y, ball.radius
            );
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.3, GAME_CONFIG.COLORS.ball);
            gradient.addColorStop(1, shadeColor(GAME_CONFIG.COLORS.ball, -30));
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Ïô∏Í≥ΩÏÑ†
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Í∂§Ï†Å Ìö®Í≥º (Ïù¥Îèô Ï§ëÏùº Îïå)
            if (!ball.stuck && (ball.dx !== 0 || ball.dy !== 0)) {
                for (let i = 1; i <= 3; i++) {
                    const trailX = ball.x - ball.dx * i * 0.5;
                    const trailY = ball.y - ball.dy * i * 0.5;
                    const trailRadius = ball.radius * (1 - i * 0.2);
                    const trailAlpha = 0.3 - i * 0.1;
                    
                    ctx.fillStyle = `rgba(245, 87, 108, ${trailAlpha})`;
                    ctx.beginPath();
                    ctx.arc(trailX, trailY, trailRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // ==================== ÌååÌã∞ÌÅ¥ Í∑∏Î¶¨Í∏∞ ====================
        function drawParticles() {
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        // ==================== Í∏∞Ïö∏Í∏∞ Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ ====================
        function drawTiltIndicator() {
            const indicatorWidth = 200;
            const indicatorHeight = 20;
            const indicatorX = canvas.width / 2 - indicatorWidth / 2;
            const indicatorY = 20;
            
            // Î∞∞Í≤Ω
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            roundRect(ctx, indicatorX, indicatorY, indicatorWidth, indicatorHeight, 10);
            ctx.fill();
            
            // Ï§ëÏïôÏÑ†
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, indicatorY);
            ctx.lineTo(canvas.width / 2, indicatorY + indicatorHeight);
            ctx.stroke();
            
            // Í∏∞Ïö∏Í∏∞ ÌëúÏãú
            const tiltX = canvas.width / 2 + currentTilt * (indicatorWidth / 2);
            ctx.fillStyle = GAME_CONFIG.COLORS.paddle;
            ctx.beginPath();
            ctx.arc(tiltX, indicatorY + indicatorHeight / 2, 8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(tiltX, indicatorY + indicatorHeight / 2, 8, 0, Math.PI * 2);
            ctx.stroke();
        }

        // ==================== Ïú†Ìã∏Î¶¨Ìã∞ Ìï®Ïàò ====================
        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        function shadeColor(color, percent) {
            const num = parseInt(color.replace("#", ""), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255))
                .toString(16).slice(1);
        }

        // ==================== Í≤åÏûÑ ÏãúÏûë ====================
        window.addEventListener('load', () => {
            console.log('üéÆ ÏÑºÏÑú Î≥º Í≤åÏûÑ Î°úÎìú ÏôÑÎ£å');
            initGame();
        });

        // ==================== ÏóêÎü¨ Ï≤òÎ¶¨ ====================
        window.addEventListener('error', (event) => {
            console.error('‚ùå ÏóêÎü¨ Î∞úÏÉù:', event.error);
        });

        // ==================== ÌéòÏù¥ÏßÄ Ïñ∏Î°úÎìú Ïãú Ï†ïÎ¶¨ ====================
        window.addEventListener('beforeunload', () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        });
    </script>
</body>
</html>