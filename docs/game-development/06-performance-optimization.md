# ‚ö° ÏÑ±Îä• ÏµúÏ†ÅÌôî - 60FPS Ïú†ÏßÄÎ•º ÏúÑÌïú ÏµúÏ†ÅÌôî Í∏∞Î≤ï

## üìö Î™©Ï∞®
1. [ÏÑ±Îä• Ï∏°Ï†ï Î∞è ÌîÑÎ°úÌååÏùºÎßÅ](#ÏÑ±Îä•-Ï∏°Ï†ï-Î∞è-ÌîÑÎ°úÌååÏùºÎßÅ)
2. [Î†åÎçîÎßÅ ÏµúÏ†ÅÌôî](#Î†åÎçîÎßÅ-ÏµúÏ†ÅÌôî)
3. [ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ ÏµúÏ†ÅÌôî](#ÏÑºÏÑú-Îç∞Ïù¥ÌÑ∞-ÏµúÏ†ÅÌôî)
4. [Î©îÎ™®Î¶¨ Í¥ÄÎ¶¨](#Î©îÎ™®Î¶¨-Í¥ÄÎ¶¨)
5. [ÎÑ§Ìä∏ÏõåÌÅ¨ ÏµúÏ†ÅÌôî](#ÎÑ§Ìä∏ÏõåÌÅ¨-ÏµúÏ†ÅÌôî)
6. [ÏΩîÎìú ÏµúÏ†ÅÌôî](#ÏΩîÎìú-ÏµúÏ†ÅÌôî)
7. [Î°úÎî© ÏãúÍ∞Ñ Îã®Ï∂ï](#Î°úÎî©-ÏãúÍ∞Ñ-Îã®Ï∂ï)
8. [Î∞∞ÌÑ∞Î¶¨ Ï†àÏïΩ](#Î∞∞ÌÑ∞Î¶¨-Ï†àÏïΩ)

---

## üìä ÏÑ±Îä• Ï∏°Ï†ï Î∞è ÌîÑÎ°úÌååÏùºÎßÅ

### 1. FPS Î™®ÎãàÌÑ∞

```javascript
class FPSMonitor {
    constructor() {
        this.frames = 0;
        this.lastTime = performance.now();
        this.fps = 60;
        this.fpsHistory = [];
        this.maxHistorySize = 60;

        this.display = this.createDisplay();
    }

    createDisplay() {
        const display = document.createElement('div');
        display.style.cssText = `
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.8);
            color: #0f0;
            font-family: monospace;
            font-size: 14px;
            border-radius: 4px;
            z-index: 10000;
            pointer-events: none;
        `;
        document.body.appendChild(display);
        return display;
    }

    update() {
        this.frames++;
        const currentTime = performance.now();
        const elapsed = currentTime - this.lastTime;

        if (elapsed >= 1000) {
            this.fps = Math.round((this.frames * 1000) / elapsed);
            this.frames = 0;
            this.lastTime = currentTime;

            this.fpsHistory.push(this.fps);
            if (this.fpsHistory.length > this.maxHistorySize) {
                this.fpsHistory.shift();
            }

            this.updateDisplay();
        }
    }

    updateDisplay() {
        const avg = this.getAverage();
        const min = Math.min(...this.fpsHistory);
        const max = Math.max(...this.fpsHistory);

        const color = this.fps >= 55 ? '#0f0' : this.fps >= 30 ? '#ff0' : '#f00';

        this.display.style.color = color;
        this.display.innerHTML = `
            FPS: ${this.fps}<br>
            Avg: ${avg} | Min: ${min} | Max: ${max}
        `;
    }

    getAverage() {
        if (this.fpsHistory.length === 0) return 0;
        const sum = this.fpsHistory.reduce((a, b) => a + b, 0);
        return Math.round(sum / this.fpsHistory.length);
    }
}

// ÏÇ¨Ïö© Ïòà
const fpsMonitor = new FPSMonitor();

function gameLoop() {
    fpsMonitor.update();
    // Í≤åÏûÑ Î°úÏßÅ...
    requestAnimationFrame(gameLoop);
}

gameLoop();
```

### 2. ÏÑ±Îä• ÌîÑÎ°úÌååÏùºÎü¨

```javascript
class PerformanceProfiler {
    constructor() {
        this.measurements = new Map();
    }

    start(label) {
        this.measurements.set(label, {
            start: performance.now(),
            samples: []
        });
    }

    end(label) {
        const measurement = this.measurements.get(label);
        if (!measurement) return;

        const duration = performance.now() - measurement.start;
        measurement.samples.push(duration);

        if (measurement.samples.length > 100) {
            measurement.samples.shift();
        }
    }

    getStats(label) {
        const measurement = this.measurements.get(label);
        if (!measurement || measurement.samples.length === 0) {
            return null;
        }

        const samples = measurement.samples;
        const sum = samples.reduce((a, b) => a + b, 0);
        const avg = sum / samples.length;
        const min = Math.min(...samples);
        const max = Math.max(...samples);

        return { avg, min, max, samples: samples.length };
    }

    report() {
        console.log('=== Performance Report ===');
        this.measurements.forEach((_, label) => {
            const stats = this.getStats(label);
            if (stats) {
                console.log(`${label}:`, {
                    avg: `${stats.avg.toFixed(2)}ms`,
                    min: `${stats.min.toFixed(2)}ms`,
                    max: `${stats.max.toFixed(2)}ms`
                });
            }
        });
    }
}

// ÏÇ¨Ïö© Ïòà
const profiler = new PerformanceProfiler();

function gameLoop() {
    profiler.start('update');
    update();
    profiler.end('update');

    profiler.start('render');
    render();
    profiler.end('render');

    profiler.start('physics');
    updatePhysics();
    profiler.end('physics');

    requestAnimationFrame(gameLoop);
}

// 5Ï¥àÎßàÎã§ Î¶¨Ìè¨Ìä∏
setInterval(() => {
    profiler.report();
}, 5000);
```

---

## üé® Î†åÎçîÎßÅ ÏµúÏ†ÅÌôî

### 1. Ïò§ÌîÑÏä§ÌÅ¨Î¶∞ Ï∫îÎ≤ÑÏä§

```javascript
class OptimizedRenderer {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d', {
            alpha: false,  // Ìà¨Î™ÖÎèÑ Î∂àÌïÑÏöî Ïãú ÏÑ±Îä• Ìñ•ÏÉÅ
            desynchronized: true  // ÎÇÆÏùÄ ÏßÄÏó∞ÏãúÍ∞Ñ
        });

        // Ïò§ÌîÑÏä§ÌÅ¨Î¶∞ Ï∫îÎ≤ÑÏä§ ÏÉùÏÑ±
        this.offscreenCanvas = document.createElement('canvas');
        this.offscreenCanvas.width = this.canvas.width;
        this.offscreenCanvas.height = this.canvas.height;
        this.offscreenCtx = this.offscreenCanvas.getContext('2d');
    }

    render(entities) {
        // Ïò§ÌîÑÏä§ÌÅ¨Î¶∞ Ï∫îÎ≤ÑÏä§Ïóê Î†åÎçîÎßÅ
        this.offscreenCtx.clearRect(
            0, 0,
            this.offscreenCanvas.width,
            this.offscreenCanvas.height
        );

        entities.forEach(entity => {
            this.drawEntity(this.offscreenCtx, entity);
        });

        // Ìïú Î≤àÏóê Î©îÏù∏ Ï∫îÎ≤ÑÏä§Î°ú Î≥µÏÇ¨
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.drawImage(this.offscreenCanvas, 0, 0);
    }

    drawEntity(ctx, entity) {
        ctx.fillStyle = entity.color;
        ctx.fillRect(entity.x, entity.y, entity.width, entity.height);
    }
}
```

### 2. ÎçîÌã∞ Î†âÌä∏ (Dirty Rectangle)

```javascript
class DirtyRectRenderer {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.dirtyRegions = [];
    }

    markDirty(x, y, width, height) {
        this.dirtyRegions.push({ x, y, width, height });
    }

    render(entities) {
        if (this.dirtyRegions.length === 0) {
            return; // Î≥ÄÍ≤Ω ÏóÜÏúºÎ©¥ Ïä§ÌÇµ
        }

        // ÎçîÌã∞ ÏòÅÏó≠Îßå ÏßÄÏö∞Í≥† Îã§Ïãú Í∑∏Î¶¨Í∏∞
        this.dirtyRegions.forEach(region => {
            this.ctx.clearRect(region.x, region.y, region.width, region.height);

            // Ìï¥Îãπ ÏòÅÏó≠Í≥º Í≤πÏπòÎäî ÏóîÌã∞Ìã∞Îßå Î†åÎçîÎßÅ
            entities.forEach(entity => {
                if (this.intersects(region, entity)) {
                    this.drawEntity(entity);
                }
            });
        });

        this.dirtyRegions = [];
    }

    intersects(rect1, rect2) {
        return !(
            rect1.x + rect1.width < rect2.x ||
            rect2.x + rect2.width < rect1.x ||
            rect1.y + rect1.height < rect2.y ||
            rect2.y + rect2.height < rect1.y
        );
    }

    drawEntity(entity) {
        this.ctx.fillStyle = entity.color;
        this.ctx.fillRect(entity.x, entity.y, entity.width, entity.height);
    }
}
```

### 3. Ïä§ÌîÑÎùºÏù¥Ìä∏ Î∞∞Ïπ≠

```javascript
class SpriteBatcher {
    constructor(ctx) {
        this.ctx = ctx;
        this.batches = new Map();
    }

    addSprite(texture, x, y, width, height) {
        if (!this.batches.has(texture)) {
            this.batches.set(texture, []);
        }

        this.batches.get(texture).push({ x, y, width, height });
    }

    flush() {
        // Í∞ôÏùÄ ÌÖçÏä§Ï≤òÎ•º ÏÇ¨Ïö©ÌïòÎäî Ïä§ÌîÑÎùºÏù¥Ìä∏Î•º Ìïú Î≤àÏóê Î†åÎçîÎßÅ
        this.batches.forEach((sprites, texture) => {
            sprites.forEach(sprite => {
                this.ctx.drawImage(
                    texture,
                    sprite.x, sprite.y,
                    sprite.width, sprite.height
                );
            });
        });

        this.batches.clear();
    }
}

// ÏÇ¨Ïö© Ïòà
const batcher = new SpriteBatcher(ctx);

entities.forEach(entity => {
    batcher.addSprite(
        entity.texture,
        entity.x, entity.y,
        entity.width, entity.height
    );
});

batcher.flush();
```

### 4. Î∑∞Ìè¨Ìä∏ Ïª¨ÎßÅ

```javascript
class ViewportCuller {
    constructor(viewportWidth, viewportHeight) {
        this.viewport = {
            x: 0,
            y: 0,
            width: viewportWidth,
            height: viewportHeight
        };
    }

    setViewport(x, y) {
        this.viewport.x = x;
        this.viewport.y = y;
    }

    isVisible(entity) {
        // Î∑∞Ìè¨Ìä∏ Î∞ñ ÏóîÌã∞Ìã∞Îäî Ï†úÏô∏
        return !(
            entity.x + entity.width < this.viewport.x ||
            entity.x > this.viewport.x + this.viewport.width ||
            entity.y + entity.height < this.viewport.y ||
            entity.y > this.viewport.y + this.viewport.height
        );
    }

    getVisibleEntities(entities) {
        return entities.filter(entity => this.isVisible(entity));
    }
}

// ÏÇ¨Ïö© Ïòà
const culler = new ViewportCuller(800, 600);

function render(entities) {
    const visibleEntities = culler.getVisibleEntities(entities);

    // Î≥¥Ïù¥Îäî ÏóîÌã∞Ìã∞Îßå Î†åÎçîÎßÅ
    visibleEntities.forEach(entity => {
        drawEntity(entity);
    });

    console.log(`Ï¥ù ${entities.length}Í∞ú Ï§ë ${visibleEntities.length}Í∞ú Î†åÎçîÎßÅ`);
}
```

---

## üì° ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ ÏµúÏ†ÅÌôî

### 1. Ïì∞Î°úÌãÄÎßÅ (Throttling)

```javascript
class SensorThrottler {
    constructor(callback, interval = 16) { // 60fps = 16ms
        this.callback = callback;
        this.interval = interval;
        this.lastTime = 0;
        this.pending = null;
    }

    process(data) {
        const now = Date.now();

        if (now - this.lastTime >= this.interval) {
            this.callback(data);
            this.lastTime = now;
            this.pending = null;
        } else {
            // ÎåÄÍ∏∞ Ï§ëÏù∏ Îç∞Ïù¥ÌÑ∞ Í∞±Ïã†
            this.pending = data;
        }
    }

    flush() {
        if (this.pending) {
            this.callback(this.pending);
            this.pending = null;
            this.lastTime = Date.now();
        }
    }
}

// ÏÇ¨Ïö© Ïòà
const throttler = new SensorThrottler((data) => {
    updateGame(data);
}, 16); // 60fps

sdk.on('sensor-data', (event) => {
    const data = event.detail || event;
    throttler.process(data.data);
});
```

### 2. ÎîîÎ∞îÏö¥Ïã± (Debouncing)

```javascript
class SensorDebouncer {
    constructor(callback, delay = 100) {
        this.callback = callback;
        this.delay = delay;
        this.timeoutId = null;
    }

    process(data) {
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
        }

        this.timeoutId = setTimeout(() => {
            this.callback(data);
            this.timeoutId = null;
        }, this.delay);
    }

    cancel() {
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
    }
}

// ÏÇ¨Ïö© Ïòà: ÌùîÎì§Í∏∞ Ï†úÏä§Ï≤ò Í∞êÏßÄÏóê Ïú†Ïö©
const shakeDebouncer = new SensorDebouncer((data) => {
    console.log('ÌùîÎì§Í∏∞ Í∞êÏßÄ!');
    onShake();
}, 300);

sdk.on('sensor-data', (event) => {
    const data = event.detail || event;
    const magnitude = Math.sqrt(
        data.data.acceleration.x ** 2 +
        data.data.acceleration.y ** 2 +
        data.data.acceleration.z ** 2
    );

    if (magnitude > 15) {
        shakeDebouncer.process(data);
    }
});
```

---

## üß† Î©îÎ™®Î¶¨ Í¥ÄÎ¶¨

### 1. Í∞ùÏ≤¥ ÌíÄ (Object Pool)

```javascript
class ObjectPool {
    constructor(factory, initialSize = 10) {
        this.factory = factory;
        this.pool = [];
        this.active = [];

        // Ï¥àÍ∏∞ Í∞ùÏ≤¥ ÏÉùÏÑ±
        for (let i = 0; i < initialSize; i++) {
            this.pool.push(this.factory());
        }
    }

    acquire() {
        let obj;

        if (this.pool.length > 0) {
            obj = this.pool.pop();
        } else {
            obj = this.factory();
        }

        this.active.push(obj);
        return obj;
    }

    release(obj) {
        const index = this.active.indexOf(obj);
        if (index !== -1) {
            this.active.splice(index, 1);
            this.pool.push(obj);

            // Í∞ùÏ≤¥ Ï¥àÍ∏∞Ìôî
            if (obj.reset) {
                obj.reset();
            }
        }
    }

    releaseAll() {
        this.active.forEach(obj => {
            if (obj.reset) {
                obj.reset();
            }
            this.pool.push(obj);
        });
        this.active = [];
    }

    getStats() {
        return {
            poolSize: this.pool.length,
            activeSize: this.active.length,
            totalSize: this.pool.length + this.active.length
        };
    }
}

// ÏÇ¨Ïö© Ïòà: Ï¥ùÏïå ÌíÄ
class Bullet {
    constructor() {
        this.x = 0;
        this.y = 0;
        this.vx = 0;
        this.vy = 0;
        this.active = false;
    }

    reset() {
        this.x = 0;
        this.y = 0;
        this.vx = 0;
        this.vy = 0;
        this.active = false;
    }

    update(deltaTime) {
        if (this.active) {
            this.x += this.vx * deltaTime;
            this.y += this.vy * deltaTime;
        }
    }
}

const bulletPool = new ObjectPool(() => new Bullet(), 50);

function shoot(x, y, vx, vy) {
    const bullet = bulletPool.acquire();
    bullet.x = x;
    bullet.y = y;
    bullet.vx = vx;
    bullet.vy = vy;
    bullet.active = true;
    return bullet;
}

function removeBullet(bullet) {
    bulletPool.release(bullet);
}
```

### 2. Î©îÎ™®Î¶¨ ÎàÑÏàò Î∞©ÏßÄ

```javascript
class MemoryLeakPrevention {
    constructor() {
        this.listeners = [];
        this.intervals = [];
        this.timeouts = [];
    }

    addEventListener(element, event, handler) {
        element.addEventListener(event, handler);
        this.listeners.push({ element, event, handler });
    }

    setInterval(callback, ms) {
        const id = setInterval(callback, ms);
        this.intervals.push(id);
        return id;
    }

    setTimeout(callback, ms) {
        const id = setTimeout(callback, ms);
        this.timeouts.push(id);
        return id;
    }

    cleanup() {
        // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï†úÍ±∞
        this.listeners.forEach(({ element, event, handler }) => {
            element.removeEventListener(event, handler);
        });
        this.listeners = [];

        // Ïù∏ÌÑ∞Î≤å Ï†úÍ±∞
        this.intervals.forEach(id => clearInterval(id));
        this.intervals = [];

        // ÌÉÄÏûÑÏïÑÏõÉ Ï†úÍ±∞
        this.timeouts.forEach(id => clearTimeout(id));
        this.timeouts = [];
    }
}

// ÏÇ¨Ïö© Ïòà
class Game {
    constructor() {
        this.memory = new MemoryLeakPrevention();
    }

    init() {
        this.memory.addEventListener(window, 'resize', () => {
            this.onResize();
        });

        this.memory.setInterval(() => {
            this.update();
        }, 16);
    }

    destroy() {
        this.memory.cleanup();
    }
}
```

---

## üåê ÎÑ§Ìä∏ÏõåÌÅ¨ ÏµúÏ†ÅÌôî

### 1. ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ ÏïïÏ∂ï

```javascript
class SensorDataCompressor {
    constructor(precision = 2) {
        this.precision = precision;
        this.lastData = null;
        this.threshold = 0.5; // Î≥ÄÌôîÎüâ ÏûÑÍ≥ÑÍ∞í
    }

    compress(sensorData) {
        // ÏÜåÏàòÏ†ê ÏûêÎ¶¨Ïàò Ï†úÌïú
        const compressed = {
            orientation: {
                alpha: this.round(sensorData.orientation.alpha),
                beta: this.round(sensorData.orientation.beta),
                gamma: this.round(sensorData.orientation.gamma)
            }
        };

        // Î≥ÄÌôîÍ∞Ä ÏûÑÍ≥ÑÍ∞í Ïù¥ÌïòÎ©¥ Ï†ÑÏÜ°ÌïòÏßÄ ÏïäÏùå
        if (this.lastData && !this.hasSignificantChange(compressed, this.lastData)) {
            return null;
        }

        this.lastData = compressed;
        return compressed;
    }

    round(value) {
        const multiplier = Math.pow(10, this.precision);
        return Math.round(value * multiplier) / multiplier;
    }

    hasSignificantChange(data1, data2) {
        const diff = Math.abs(
            data1.orientation.alpha - data2.orientation.alpha +
            data1.orientation.beta - data2.orientation.beta +
            data1.orientation.gamma - data2.orientation.gamma
        );

        return diff > this.threshold;
    }
}

// ÏÇ¨Ïö© Ïòà
const compressor = new SensorDataCompressor(1); // ÏÜåÏàòÏ†ê 1ÏûêÎ¶¨

sdk.on('sensor-data', (event) => {
    const data = event.detail || event;
    const compressed = compressor.compress(data.data);

    if (compressed) {
        // ÏùòÎØ∏ ÏûàÎäî Î≥ÄÌôîÎßå Ï†ÑÏÜ°
        sendToServer(compressed);
    }
});
```

### 2. Îç∏ÌÉÄ Ïù∏ÏΩîÎî©

```javascript
class DeltaEncoder {
    constructor() {
        this.lastData = null;
    }

    encode(data) {
        if (!this.lastData) {
            this.lastData = { ...data };
            return { type: 'full', data };
        }

        const delta = {
            alpha: data.alpha - this.lastData.alpha,
            beta: data.beta - this.lastData.beta,
            gamma: data.gamma - this.lastData.gamma
        };

        this.lastData = { ...data };

        return { type: 'delta', delta };
    }

    decode(encoded) {
        if (encoded.type === 'full') {
            this.lastData = { ...encoded.data };
            return encoded.data;
        } else {
            const data = {
                alpha: this.lastData.alpha + encoded.delta.alpha,
                beta: this.lastData.beta + encoded.delta.beta,
                gamma: this.lastData.gamma + encoded.delta.gamma
            };

            this.lastData = { ...data };
            return data;
        }
    }
}
```

---

## üîß ÏΩîÎìú ÏµúÏ†ÅÌôî

### 1. Î£®ÌîÑ ÏµúÏ†ÅÌôî

```javascript
// ‚ùå ÎäêÎ¶∞ ÏΩîÎìú
function updateEntities(entities) {
    for (let i = 0; i < entities.length; i++) {
        if (entities[i].active) {
            entities[i].update();
            entities[i].checkCollision();
            entities[i].render();
        }
    }
}

// ‚úÖ Îπ†Î•∏ ÏΩîÎìú
function updateEntities(entities) {
    const length = entities.length;

    // ÌôúÏÑ± ÏóîÌã∞Ìã∞Îßå ÏóÖÎç∞Ïù¥Ìä∏
    for (let i = 0; i < length; i++) {
        const entity = entities[i];
        if (!entity.active) continue;

        entity.update();
    }

    // Ï∂©Îèå Í≤ÄÏÇ¨ (Î≥ÑÎèÑ Î£®ÌîÑ)
    for (let i = 0; i < length; i++) {
        const entity = entities[i];
        if (!entity.active) continue;

        entity.checkCollision();
    }

    // Î†åÎçîÎßÅ (Î≥ÑÎèÑ Î£®ÌîÑ)
    for (let i = 0; i < length; i++) {
        const entity = entities[i];
        if (!entity.active) continue;

        entity.render();
    }
}
```

### 2. ÏàòÌïô Ïó∞ÏÇ∞ ÏµúÏ†ÅÌôî

```javascript
// ‚ùå ÎäêÎ¶∞ ÏΩîÎìú
const distance = Math.sqrt(
    Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)
);

// ‚úÖ Îπ†Î•∏ ÏΩîÎìú
const dx = x2 - x1;
const dy = y2 - y1;
const distance = Math.sqrt(dx * dx + dy * dy);

// ‚úÖ Îçî Îπ†Î•∏ ÏΩîÎìú (Ï†úÍ≥±Í∑º ÏÉùÎûµ Í∞ÄÎä•Ìïú Í≤ΩÏö∞)
const distanceSquared = dx * dx + dy * dy;
if (distanceSquared < radiusSquared) {
    // Ï∂©Îèå!
}

// ÏÇºÍ∞Å Ìï®Ïàò Ï∫êÏã±
class TrigCache {
    constructor() {
        this.sinCache = new Float32Array(360);
        this.cosCache = new Float32Array(360);

        for (let i = 0; i < 360; i++) {
            const rad = (i * Math.PI) / 180;
            this.sinCache[i] = Math.sin(rad);
            this.cosCache[i] = Math.cos(rad);
        }
    }

    sin(degrees) {
        return this.sinCache[Math.floor(degrees) % 360];
    }

    cos(degrees) {
        return this.cosCache[Math.floor(degrees) % 360];
    }
}

const trig = new TrigCache();

// ÏÇ¨Ïö©
const x = trig.cos(angle) * radius;
const y = trig.sin(angle) * radius;
```

---

## ‚ö° Î°úÎî© ÏãúÍ∞Ñ Îã®Ï∂ï

### ÏßÄÏó∞ Î°úÎî© (Lazy Loading)

```javascript
class AssetLoader {
    constructor() {
        this.assets = new Map();
        this.loading = new Map();
    }

    async load(url, type = 'image') {
        // Ïù¥ÎØ∏ Î°úÎìúÎêú Í≤ΩÏö∞
        if (this.assets.has(url)) {
            return this.assets.get(url);
        }

        // Î°úÎî© Ï§ëÏù∏ Í≤ΩÏö∞
        if (this.loading.has(url)) {
            return this.loading.get(url);
        }

        // ÏÉàÎ°ú Î°úÎìú
        const promise = this.loadAsset(url, type);
        this.loading.set(url, promise);

        try {
            const asset = await promise;
            this.assets.set(url, asset);
            this.loading.delete(url);
            return asset;
        } catch (error) {
            this.loading.delete(url);
            throw error;
        }
    }

    async loadAsset(url, type) {
        switch(type) {
            case 'image':
                return this.loadImage(url);
            case 'audio':
                return this.loadAudio(url);
            default:
                throw new Error(`Unknown asset type: ${type}`);
        }
    }

    loadImage(url) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = url;
        });
    }

    loadAudio(url) {
        return new Promise((resolve, reject) => {
            const audio = new Audio();
            audio.oncanplaythrough = () => resolve(audio);
            audio.onerror = reject;
            audio.src = url;
        });
    }
}

// ÏÇ¨Ïö© Ïòà
const loader = new AssetLoader();

// ÌïÑÏöîÌï† ÎïåÎßå Î°úÎìú
async function showLevel(levelId) {
    const background = await loader.load(`/images/level${levelId}_bg.png`);
    const music = await loader.load(`/audio/level${levelId}_music.mp3`, 'audio');

    // ÏÇ¨Ïö©...
}
```

---

## üîã Î∞∞ÌÑ∞Î¶¨ Ï†àÏïΩ

```javascript
class BatteryOptimizer {
    constructor() {
        this.isPaused = false;
        this.isVisible = true;
        this.setupVisibilityChange();
    }

    setupVisibilityChange() {
        document.addEventListener('visibilitychange', () => {
            this.isVisible = !document.hidden;

            if (!this.isVisible) {
                this.onBackground();
            } else {
                this.onForeground();
            }
        });
    }

    onBackground() {
        console.log('Ïï±Ïù¥ Î∞±Í∑∏ÎùºÏö¥ÎìúÎ°ú Ï†ÑÌôòÎê® - Ï†àÏ†Ñ Î™®Îìú');
        this.isPaused = true;

        // ÌîÑÎ†àÏûÑÎ•† Í∞êÏÜå
        // ÏÑºÏÑú ÏóÖÎç∞Ïù¥Ìä∏ ÎπàÎèÑ Í∞êÏÜå
        // Î†åÎçîÎßÅ Ï§ëÏßÄ
    }

    onForeground() {
        console.log('Ïï±Ïù¥ Ìè¨Í∑∏ÎùºÏö¥ÎìúÎ°ú Î≥µÍ∑Ä - Ï†ïÏÉÅ Î™®Îìú');
        this.isPaused = false;

        // Ï†ïÏÉÅ ÌîÑÎ†àÏûÑÎ•† Î≥µÍµ¨
    }
}

const batteryOptimizer = new BatteryOptimizer();

function gameLoop() {
    if (!batteryOptimizer.isPaused) {
        update();
        render();
    }

    requestAnimationFrame(gameLoop);
}
```

---

## üéì ÌïµÏã¨ ÏõêÏπô ÏöîÏïΩ

1. **Ï∏°Ï†ï Ïö∞ÏÑ†**: ÏµúÏ†ÅÌôî Ï†Ñ ÏÑ±Îä• Ï∏°Ï†ï Î∞è Î≥ëÎ™© ÏßÄÏ†ê ÌååÏïÖ
2. **Î†åÎçîÎßÅ ÏµúÏ†ÅÌôî**: Ïò§ÌîÑÏä§ÌÅ¨Î¶∞ Ï∫îÎ≤ÑÏä§, ÎçîÌã∞ Î†âÌä∏, Î∑∞Ìè¨Ìä∏ Ïª¨ÎßÅ
3. **Î©îÎ™®Î¶¨ Í¥ÄÎ¶¨**: Í∞ùÏ≤¥ ÌíÄ, Î©îÎ™®Î¶¨ ÎàÑÏàò Î∞©ÏßÄ
4. **ÎÑ§Ìä∏ÏõåÌÅ¨ Ï†àÏïΩ**: Îç∞Ïù¥ÌÑ∞ ÏïïÏ∂ï, Îç∏ÌÉÄ Ïù∏ÏΩîÎî©
5. **Î∞∞ÌÑ∞Î¶¨ Ï†àÏïΩ**: Î∞±Í∑∏ÎùºÏö¥Îìú ÏùºÏãú Ï†ïÏßÄ, Ï†ÅÏùëÌòï ÌîÑÎ†àÏûÑÎ•†

---

## üìñ Îã§Ïùå Îã®Í≥Ñ

- [ÏïÑÌÇ§ÌÖçÏ≤ò ÎîîÏûêÏù∏](./01-architecture-design.md)
- [SessionSDK Ïã¨Ìôî](./02-sessionsdk-advanced.md)
- [ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ ÎßàÏä§ÌÑ∞Î¶¨](./03-sensor-data-mastery.md)
